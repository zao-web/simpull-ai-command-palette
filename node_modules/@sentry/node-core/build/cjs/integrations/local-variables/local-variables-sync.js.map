{"version":3,"file":"local-variables-sync.js","sources":["../../../../src/integrations/local-variables/local-variables-sync.ts"],"sourcesContent":["import type { Debugger, InspectorNotification, Runtime, Session } from 'node:inspector';\nimport type { Event, Exception, IntegrationFn, StackFrame, StackParser } from '@sentry/core';\nimport { debug, defineIntegration, getClient, LRUMap } from '@sentry/core';\nimport { NODE_MAJOR } from '../../nodeVersion';\nimport type { NodeClient } from '../../sdk/client';\nimport { isDebuggerEnabled } from '../../utils/debug';\nimport type {\n  FrameVariables,\n  LocalVariablesIntegrationOptions,\n  PausedExceptionEvent,\n  RateLimitIncrement,\n  Variables,\n} from './common';\nimport { createRateLimiter, functionNamesMatch } from './common';\n\n/** Creates a unique hash from stack frames */\nexport function hashFrames(frames: StackFrame[] | undefined): string | undefined {\n  if (frames === undefined) {\n    return;\n  }\n\n  // Only hash the 10 most recent frames (ie. the last 10)\n  return frames.slice(-10).reduce((acc, frame) => `${acc},${frame.function},${frame.lineno},${frame.colno}`, '');\n}\n\n/**\n * We use the stack parser to create a unique hash from the exception stack trace\n * This is used to lookup vars when the exception passes through the event processor\n */\nexport function hashFromStack(stackParser: StackParser, stack: string | undefined): string | undefined {\n  if (stack === undefined) {\n    return undefined;\n  }\n\n  return hashFrames(stackParser(stack, 1));\n}\n\ntype OnPauseEvent = InspectorNotification<Debugger.PausedEventDataType>;\nexport interface DebugSession {\n  /** Configures and connects to the debug session */\n  configureAndConnect(onPause: (message: OnPauseEvent, complete: () => void) => void, captureAll: boolean): void;\n  /** Updates which kind of exceptions to capture */\n  setPauseOnExceptions(captureAll: boolean): void;\n  /** Gets local variables for an objectId */\n  getLocalVariables(objectId: string, callback: (vars: Variables) => void): void;\n}\n\ntype Next<T> = (result: T) => void;\ntype Add<T> = (fn: Next<T>) => void;\ntype CallbackWrapper<T> = { add: Add<T>; next: Next<T> };\n\n/** Creates a container for callbacks to be called sequentially */\nexport function createCallbackList<T>(complete: Next<T>): CallbackWrapper<T> {\n  // A collection of callbacks to be executed last to first\n  let callbacks: Next<T>[] = [];\n\n  let completedCalled = false;\n  function checkedComplete(result: T): void {\n    callbacks = [];\n    if (completedCalled) {\n      return;\n    }\n    completedCalled = true;\n    complete(result);\n  }\n\n  // complete should be called last\n  callbacks.push(checkedComplete);\n\n  function add(fn: Next<T>): void {\n    callbacks.push(fn);\n  }\n\n  function next(result: T): void {\n    const popped = callbacks.pop() || checkedComplete;\n\n    try {\n      popped(result);\n    } catch {\n      // If there is an error, we still want to call the complete callback\n      checkedComplete(result);\n    }\n  }\n\n  return { add, next };\n}\n\n/**\n * Promise API is available as `Experimental` and in Node 19 only.\n *\n * Callback-based API is `Stable` since v14 and `Experimental` since v8.\n * Because of that, we are creating our own `AsyncSession` class.\n *\n * https://nodejs.org/docs/latest-v19.x/api/inspector.html#promises-api\n * https://nodejs.org/docs/latest-v14.x/api/inspector.html\n */\nclass AsyncSession implements DebugSession {\n  /** Throws if inspector API is not available */\n  private constructor(private readonly _session: Session) {\n    //\n  }\n\n  public static async create(orDefault?: DebugSession | undefined): Promise<DebugSession> {\n    if (orDefault) {\n      return orDefault;\n    }\n\n    const inspector = await import('node:inspector');\n    return new AsyncSession(new inspector.Session());\n  }\n\n  /** @inheritdoc */\n  public configureAndConnect(onPause: (event: OnPauseEvent, complete: () => void) => void, captureAll: boolean): void {\n    this._session.connect();\n\n    this._session.on('Debugger.paused', event => {\n      onPause(event, () => {\n        // After the pause work is complete, resume execution or the exception context memory is leaked\n        this._session.post('Debugger.resume');\n      });\n    });\n\n    this._session.post('Debugger.enable');\n    this._session.post('Debugger.setPauseOnExceptions', { state: captureAll ? 'all' : 'uncaught' });\n  }\n\n  public setPauseOnExceptions(captureAll: boolean): void {\n    this._session.post('Debugger.setPauseOnExceptions', { state: captureAll ? 'all' : 'uncaught' });\n  }\n\n  /** @inheritdoc */\n  public getLocalVariables(objectId: string, complete: (vars: Variables) => void): void {\n    this._getProperties(objectId, props => {\n      const { add, next } = createCallbackList<Variables>(complete);\n\n      for (const prop of props) {\n        if (prop.value?.objectId && prop.value.className === 'Array') {\n          const id = prop.value.objectId;\n          add(vars => this._unrollArray(id, prop.name, vars, next));\n        } else if (prop.value?.objectId && prop.value.className === 'Object') {\n          const id = prop.value.objectId;\n          add(vars => this._unrollObject(id, prop.name, vars, next));\n        } else if (prop.value) {\n          add(vars => this._unrollOther(prop, vars, next));\n        }\n      }\n\n      next({});\n    });\n  }\n\n  /**\n   * Gets all the PropertyDescriptors of an object\n   */\n  private _getProperties(objectId: string, next: (result: Runtime.PropertyDescriptor[]) => void): void {\n    this._session.post(\n      'Runtime.getProperties',\n      {\n        objectId,\n        ownProperties: true,\n      },\n      (err, params) => {\n        if (err) {\n          next([]);\n        } else {\n          next(params.result);\n        }\n      },\n    );\n  }\n\n  /**\n   * Unrolls an array property\n   */\n  private _unrollArray(objectId: string, name: string, vars: Variables, next: (vars: Variables) => void): void {\n    this._getProperties(objectId, props => {\n      vars[name] = props\n        .filter(v => v.name !== 'length' && !isNaN(parseInt(v.name, 10)))\n        .sort((a, b) => parseInt(a.name, 10) - parseInt(b.name, 10))\n        .map(v => v.value?.value);\n\n      next(vars);\n    });\n  }\n\n  /**\n   * Unrolls an object property\n   */\n  private _unrollObject(objectId: string, name: string, vars: Variables, next: (obj: Variables) => void): void {\n    this._getProperties(objectId, props => {\n      vars[name] = props\n        .map<[string, unknown]>(v => [v.name, v.value?.value])\n        .reduce((obj, [key, val]) => {\n          obj[key] = val;\n          return obj;\n        }, {} as Variables);\n\n      next(vars);\n    });\n  }\n\n  /**\n   * Unrolls other properties\n   */\n  private _unrollOther(prop: Runtime.PropertyDescriptor, vars: Variables, next: (vars: Variables) => void): void {\n    if (prop.value) {\n      if ('value' in prop.value) {\n        if (prop.value.value === undefined || prop.value.value === null) {\n          vars[prop.name] = `<${prop.value.value}>`;\n        } else {\n          vars[prop.name] = prop.value.value;\n        }\n      } else if ('description' in prop.value && prop.value.type !== 'function') {\n        vars[prop.name] = `<${prop.value.description}>`;\n      } else if (prop.value.type === 'undefined') {\n        vars[prop.name] = '<undefined>';\n      }\n    }\n\n    next(vars);\n  }\n}\n\nconst INTEGRATION_NAME = 'LocalVariables';\n\n/**\n * Adds local variables to exception frames\n */\nconst _localVariablesSyncIntegration = ((\n  options: LocalVariablesIntegrationOptions = {},\n  sessionOverride?: DebugSession,\n) => {\n  const cachedFrames: LRUMap<string, FrameVariables[]> = new LRUMap(20);\n  let rateLimiter: RateLimitIncrement | undefined;\n  let shouldProcessEvent = false;\n\n  function addLocalVariablesToException(exception: Exception): void {\n    const hash = hashFrames(exception.stacktrace?.frames);\n\n    if (hash === undefined) {\n      return;\n    }\n\n    // Check if we have local variables for an exception that matches the hash\n    // remove is identical to get but also removes the entry from the cache\n    const cachedFrame = cachedFrames.remove(hash);\n\n    if (cachedFrame === undefined) {\n      return;\n    }\n\n    // Filter out frames where the function name is `new Promise` since these are in the error.stack frames\n    // but do not appear in the debugger call frames\n    const frames = (exception.stacktrace?.frames || []).filter(frame => frame.function !== 'new Promise');\n\n    for (let i = 0; i < frames.length; i++) {\n      // Sentry frames are in reverse order\n      const frameIndex = frames.length - i - 1;\n\n      const cachedFrameVariable = cachedFrame[i];\n      const frameVariable = frames[frameIndex];\n\n      // Drop out if we run out of frames to match up\n      if (!frameVariable || !cachedFrameVariable) {\n        break;\n      }\n\n      if (\n        // We need to have vars to add\n        cachedFrameVariable.vars === undefined ||\n        // We're not interested in frames that are not in_app because the vars are not relevant\n        frameVariable.in_app === false ||\n        // The function names need to match\n        !functionNamesMatch(frameVariable.function, cachedFrameVariable.function)\n      ) {\n        continue;\n      }\n\n      frameVariable.vars = cachedFrameVariable.vars;\n    }\n  }\n\n  function addLocalVariablesToEvent(event: Event): Event {\n    for (const exception of event.exception?.values || []) {\n      addLocalVariablesToException(exception);\n    }\n\n    return event;\n  }\n\n  return {\n    name: INTEGRATION_NAME,\n    async setupOnce() {\n      const client = getClient<NodeClient>();\n      const clientOptions = client?.getOptions();\n\n      if (!clientOptions?.includeLocalVariables) {\n        return;\n      }\n\n      // Only setup this integration if the Node version is >= v18\n      // https://github.com/getsentry/sentry-javascript/issues/7697\n      const unsupportedNodeVersion = NODE_MAJOR < 18;\n\n      if (unsupportedNodeVersion) {\n        debug.log('The `LocalVariables` integration is only supported on Node >= v18.');\n        return;\n      }\n\n      if (await isDebuggerEnabled()) {\n        debug.warn('Local variables capture has been disabled because the debugger was already enabled');\n        return;\n      }\n\n      AsyncSession.create(sessionOverride).then(\n        session => {\n          function handlePaused(\n            stackParser: StackParser,\n            { params: { reason, data, callFrames } }: InspectorNotification<PausedExceptionEvent>,\n            complete: () => void,\n          ): void {\n            if (reason !== 'exception' && reason !== 'promiseRejection') {\n              complete();\n              return;\n            }\n\n            rateLimiter?.();\n\n            // data.description contains the original error.stack\n            const exceptionHash = hashFromStack(stackParser, data.description);\n\n            if (exceptionHash == undefined) {\n              complete();\n              return;\n            }\n\n            const { add, next } = createCallbackList<FrameVariables[]>(frames => {\n              cachedFrames.set(exceptionHash, frames);\n              complete();\n            });\n\n            // Because we're queuing up and making all these calls synchronously, we can potentially overflow the stack\n            // For this reason we only attempt to get local variables for the first 5 frames\n            for (let i = 0; i < Math.min(callFrames.length, 5); i++) {\n              // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n              const { scopeChain, functionName, this: obj } = callFrames[i]!;\n\n              const localScope = scopeChain.find(scope => scope.type === 'local');\n\n              // obj.className is undefined in ESM modules\n              const fn =\n                obj.className === 'global' || !obj.className ? functionName : `${obj.className}.${functionName}`;\n\n              if (localScope?.object.objectId === undefined) {\n                add(frames => {\n                  frames[i] = { function: fn };\n                  next(frames);\n                });\n              } else {\n                const id = localScope.object.objectId;\n                add(frames =>\n                  session.getLocalVariables(id, vars => {\n                    frames[i] = { function: fn, vars };\n                    next(frames);\n                  }),\n                );\n              }\n            }\n\n            next([]);\n          }\n\n          const captureAll = options.captureAllExceptions !== false;\n\n          session.configureAndConnect(\n            (ev, complete) =>\n              handlePaused(clientOptions.stackParser, ev as InspectorNotification<PausedExceptionEvent>, complete),\n            captureAll,\n          );\n\n          if (captureAll) {\n            const max = options.maxExceptionsPerSecond || 50;\n\n            rateLimiter = createRateLimiter(\n              max,\n              () => {\n                debug.log('Local variables rate-limit lifted.');\n                session.setPauseOnExceptions(true);\n              },\n              seconds => {\n                debug.log(\n                  `Local variables rate-limit exceeded. Disabling capturing of caught exceptions for ${seconds} seconds.`,\n                );\n                session.setPauseOnExceptions(false);\n              },\n            );\n          }\n\n          shouldProcessEvent = true;\n        },\n        error => {\n          debug.log('The `LocalVariables` integration failed to start.', error);\n        },\n      );\n    },\n    processEvent(event: Event): Event {\n      if (shouldProcessEvent) {\n        return addLocalVariablesToEvent(event);\n      }\n\n      return event;\n    },\n    // These are entirely for testing\n    _getCachedFramesCount(): number {\n      return cachedFrames.size;\n    },\n    _getFirstCachedFrame(): FrameVariables[] | undefined {\n      return cachedFrames.values()[0];\n    },\n  };\n}) satisfies IntegrationFn;\n\n/**\n * Adds local variables to exception frames.\n */\nexport const localVariablesSyncIntegration = defineIntegration(_localVariablesSyncIntegration);\n"],"names":["LRUMap","functionNamesMatch","getClient","NODE_MAJOR","debug","isDebuggerEnabled","createRateLimiter","defineIntegration"],"mappings":"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"}